<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pose Detection with Pyodide</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.18.1/full/pyodide.js"></script>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <input type="file" accept="image/*" onchange="loadImage(event)">
  <script>
    async function loadPyodideAndRun() {
      let pyodide = await loadPyodide({
        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.18.1/full/"
      });

      await pyodide.loadPackage("micropip");
      const micropip = pyodide.pyimport("micropip");

      await micropip.install("mediapipe==0.8.10.1");

      // Ensure that OpenCV.js is loaded
      await new Promise((resolve) => {
        cv['onRuntimeInitialized'] = () => {
          resolve(cv);
        };
      });

      const pythonCode = `
import cv2
import mediapipe as mp
import time
import js
import numpy as np

cv = js.globalThis.cv

mpDraw = mp.solutions.drawing_utils
mpPose = mp.solutions.pose
pose = mpPose.Pose()

pTime = 0

def process_image(base64_image):
    global pTime

    # Decode the base64 image to OpenCV.js Mat
    img_data = js.b64decode(base64_image)
    np_arr = np.frombuffer(img_data, np.uint8)
    img = cv.imdecode(np_arr, cv.IMREAD_COLOR)

    # Convert image to RGB
    imgRGB = cv.cvtColor(img, cv.COLOR_BGR2RGB)
    results = pose.process(imgRGB)

    # Draw landmarks if pose landmarks are detected
    if results.pose_landmarks:
        mpDraw.draw_landmarks(img, results.pose_landmarks, mpPose.POSE_CONNECTIONS)
        for id, lm in enumerate(results.pose_landmarks.landmark):
            h, w, c = img.shape
            cx, cy = int(lm.x * w), int(lm.y * h)
            cv.circle(img, (cx, cy), 5, (255, 0, 0), cv.FILLED)

    cTime = time.time()
    fps = 1 / (cTime - pTime)
    pTime = cTime

    cv.putText(img, str(int(fps)), (70, 50), cv.FONT_HERSHEY_PLAIN, 3, (255, 0, 0), 3)

    # Convert the processed image back to base64
    _, buffer = cv.imencode('.jpg', img)
    processed_img_data = js.btoa(buffer.tobytes())
    return processed_img_data

class poseDetector():
    def __init__(self, mode=False, model_complexity=1, smooth=True, detectionCon=0.5, trackCon=0.5):
        self.mode = mode
        self.model_complexity = model_complexity
        self.smooth = smooth
        self.detectionCon = detectionCon
        self.trackCon = trackCon

    def findPose(self, img, draw=True):
        imgRGB = cv.cvtColor(img, cv.COLOR_BGR2RGB)
        self.results = pose.process(imgRGB)
        if self.results.pose_landmarks:
            if draw:
                mpDraw.draw_landmarks(img, self.results.pose_landmarks, mpPose.POSE_CONNECTIONS)
        return img

    def findPosition(self, img, draw=True):
        self.lmList = []
        if self.results.pose_landmarks:
            for id, lm in enumerate(self.results.pose_landmarks.landmark):
                h, w, c = img.shape
                cx, cy = int(lm.x * w), int(lm.y * h)
                self.lmList.append([id, cx, cy])
                if draw:
                    cv.circle(img, (cx, cy), 5, (255, 0, 0), cv.FILLED)
        return self.lmList

    def findAngle(self, img, p1, p2, p3, draw=True):
        x1, y1 = self.lmList[p1][1:]
        x2, y2 = self.lmList[p2][1:]
        x3, y3 = self.lmList[p3][1:]

        angle = math.degrees(math.atan2(y3 - y2, x3 - x2) - math.atan2(y1 - y2, x1 - x2))
        if angle < 0:
            angle += 360

        if draw:
            cv.line(img, (x1, y1), (x2, y2), (255, 255, 255), 3)
            cv.line(img, (x3, y3), (x2, y2), (255, 255, 255), 3)
            cv.circle(img, (x1, y1), 10, (0, 0, 255), cv.FILLED)
            cv.circle(img, (x1, y1), 15, (0, 0, 255), 2)
            cv.circle(img, (x2, y2), 10, (0, 0, 255), cv.FILLED)
            cv.circle(img, (x2, y2), 15, (0, 0, 255), 2)
            cv.circle(img, (x3, y3), 10, (0, 0, 255), cv.FILLED)
            cv.circle(img, (x3, y3), 15, (0, 0, 255), 2)
            cv.putText(img, str(int(angle)), (x2 - 50, y2 + 50), cv.FONT_HERSHEY_PLAIN, 2, (0, 0, 255), 2)
        return angle

def process_frame(base64_image, detector):
    global pTime

    # Decode the base64 image to OpenCV.js Mat
    img_data = js.b64decode(base64_image)
    np_arr = np.frombuffer(img_data, np.uint8)
    img = cv.imdecode(np_arr, cv.IMREAD_COLOR)

    img = detector.findPose(img)
    lmList = detector.findPosition(img, draw=False)

    feedback = ""
    reps = 0

    if lmList:
        elbow = lmList[13] if 'left' else lmList[14]
        wrist = lmList[15] if 'left' else lmList[16]
        shoulder = lmList[11] if 'left' else lmList[12]

        # Check if the arm is fully extended
        if abs(elbow[1] - wrist[1]) > 80:
            feedback = "Fully extend your arm"
        elif wrist[1] > shoulder[1] + 80:
            feedback = "Raise your arm to the side"
        elif wrist[2] > shoulder[2] + 80:
            feedback = "Raise your arm higher"
        elif wrist[1] > shoulder[1] + 150:
            feedback = "Move arm left a bit"
        elif wrist[1] < shoulder[1] - 150:
            feedback = "Move arm right a bit"
        elif wrist[2] > shoulder[2] + 150:
            feedback = "Move arm up a bit"
        elif wrist[2] < shoulder[2] - 150:
            feedback = "Move arm down a bit"

        if feedback == "":
            if not raised_flag:
                raised_flag = True
            else:
                raised_flag = False
                reps += 1

    cTime = time.time()
    fps = 1 / (cTime - pTime)
    pTime = cTime

    cv.putText(img, str(int(fps)), (70, 50), cv.FONT_HERSHEY_PLAIN, 3, (255, 0, 0), 3)

    # Convert the processed image back to base64
    _, buffer = cv.imencode('.jpg', img)
    processed_img_data = js.btoa(buffer.tobytes())
    return {"processed_img": processed_img_data, "feedback": feedback, "reps": reps}
`;

      await pyodide.runPythonAsync(pythonCode);

      // Function to process frame and return feedback and reps
      window.processFrame = async function(base64Image) {
        let result = await pyodide.runPythonAsync(`
          process_image("${base64Image}")
        `);
        return result;
      };
    }
    loadPyodideAndRun();

    function loadImage(event) {
      let file = event.target.files[0];
      let reader = new FileReader();
      reader.onload = async function() {
        let base64Image = reader.result.split(',')[1];
        let result = await processFrame(base64Image);
        let imgElement = document.createElement("img");
        imgElement.src = 'data:image/jpeg;base64,' + result.processed_img;
        document.body.appendChild(imgElement);
      }
      reader.readAsDataURL(file);
    }
  </script>
</body>
</html>
