<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pose Detection with Pyodide</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.18.1/full/pyodide.js"></script>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
    async function loadPyodideAndRun() {
      let pyodide = await loadPyodide({
        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.18.1/full/"
      });

      await pyodide.loadPackage("micropip");
      const micropip = pyodide.pyimport("micropip");

      await micropip.install(["mediapipe"]);

      // Ensure that OpenCV.js is loaded
      await new Promise((resolve) => {
        cv['onRuntimeInitialized'] = () => {
          resolve(cv);
        };
      });

      await pyodide.runPythonAsync(`
        import cv2
        import mediapipe as mp
        import time
        import js
        import numpy as np

        cv = js.globalThis.cv

        mpDraw = mp.solutions.drawing_utils
        mpPose = mp.solutions.pose
        pose = mpPose.Pose()

        pTime = 0

        def process_image(base64_image):
            global pTime

            # Decode the base64 image to OpenCV.js Mat
            img_data = js.b64decode(base64_image)
            np_arr = np.frombuffer(img_data, np.uint8)
            img = cv.imdecode(np_arr, cv.IMREAD_COLOR)

            # Convert image to RGB
            imgRGB = cv.cvtColor(img, cv.COLOR_BGR2RGB)
            results = pose.process(imgRGB)

            # Draw landmarks if pose landmarks are detected
            if results.pose_landmarks:
                mpDraw.draw_landmarks(img, results.pose_landmarks, mpPose.POSE_CONNECTIONS)
                for id, lm in enumerate(results.pose_landmarks.landmark):
                    h, w, c = img.shape
                    cx, cy = int(lm.x * w), int(lm.y * h)
                    cv.circle(img, (cx, cy), 5, (255, 0, 0), cv.FILLED)

            cTime = time.time()
            fps = 1 / (cTime - pTime)
            pTime = cTime

            cv.putText(img, str(int(fps)), (70, 50), cv.FONT_HERSHEY_PLAIN, 3, (255, 0, 0), 3)

            # Convert the processed image back to base64
            _, buffer = cv.imencode('.jpg', img)
            processed_img_data = js.btoa(buffer.tobytes())
            return processed_img_data
      `);

      // Function to process frame and return feedback and reps
      window.processFrame = async function(base64Image) {
        let result = await pyodide.runPythonAsync(`
          process_image("${base64Image}")
        `);
        return result;
      };
    }
    loadPyodideAndRun();
  </script>
</head>
<body>
  <input type="file" accept="image/*" onchange="loadImage(event)">
  <script>
    function loadImage(event) {
      let file = event.target.files[0];
      let reader = new FileReader();
      reader.onload = async function() {
        let base64Image = reader.result.split(',')[1];
        let result = await processFrame(base64Image);
        let imgElement = document.createElement("img");
        imgElement.src = 'data:image/jpeg;base64,' + result;
        document.body.appendChild(imgElement);
      }
      reader.readAsDataURL(file);
    }
  </script>
</body>
</html>
